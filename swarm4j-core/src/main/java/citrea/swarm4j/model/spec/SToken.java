package citrea.swarm4j.model.spec;

import java.util.Comparator;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * One token from specifier.
 * Each token starts with quant (@see SpecQuant) then body.
 * Body consists of two parts: bare and processId(optional) separated by "+" symbol.
 *
 * Common format for processId is "user~session".
 * processId specifies where the token was generated.
 *
 * @see citrea.swarm4j.model.spec.TypeToken
 * @see citrea.swarm4j.model.spec.IdToken
 * @see citrea.swarm4j.model.spec.VersionToken
 * @see citrea.swarm4j.model.spec.OpToken
 * @see SQuant
 * @see Spec
 *
 * Created with IntelliJ IDEA.
 * @author aleksisha
 *         Date: 27/10/13
 *         Time: 12:54
 */
public class SToken implements Comparable<SToken> {

    public static final String RS_TOK = "[0-9A-Za-z_~]+";
    public static final String RS_Q_TOK_EXT = ("([$])((=)(?:\\+(=))?)")
            .replaceAll("\\$", SQuant.allCodes)
            .replaceAll("=", RS_TOK);
    public static final Pattern RE_Q_TOK_EXT = Pattern.compile(RS_Q_TOK_EXT);
    public static final String RS_TOK_EXT = "^(=)(?:\\+(=))?$".replaceAll("=", RS_TOK);
    public static final String NO_AUTHOR = "swarm";

    public static final long EPOCH = 1262275200000L; // 1 Jan 2010 (milliseconds)
    public static final VersionToken ZERO_VERSION = new VersionToken("!0");
    public static final String BASE64 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~";
    public static final String RS_BASE64 = "[0-9A-Za-z_~]";
    public static final Pattern RE_BASE64 = Pattern.compile(RS_BASE64);

    // "bare+processId"
    private final String str;
    private boolean parsed;

    // parsed parts
    private SQuant quant;
    private String bare;
    private String processId;

    SToken(String tokenAsString) {
        // TODO ??? validate format
        this.str = tokenAsString;
        this.parsed = false;
    }

    SToken(SQuant quant, String body) {
        this.quant = quant;
        parseBody(body);
        this.parsed = true;
        this.str = quant.code + this.bare + (NO_AUTHOR.equals(this.processId) ? "" : "+" + this.processId);
    }

    SToken(SQuant quant, String bare, String processId) {
        this.quant = quant;
        this.bare = bare;
        this.processId = (processId != null && processId.length() > 0) ? processId : NO_AUTHOR;
        this.parsed = true;
        this.str = quant.code + this.bare + (NO_AUTHOR.equals(this.processId) ? "" : "+" + this.processId);
    }

    /** Swarm employs 30bit integer Unix-like timestamps starting epoch at
     *  1 Jan 2010. Timestamps are encoded as 5-char base64 tokens; in case
     *  several events are generated by the same process at the same second
     *  then sequence number is added so a timestamp may be more than 5
     *  chars.
     */
    public static String date2ts(Date date) {
        long time = date.getTime();
        time -= SToken.EPOCH;
        return int2base((int) (time / 1000), 5);
    }

    private static final String PADDING_ZEROS = "0000000000000000";

    public static String int2base(int i, Integer padlen) {
        if (i < 0 || i >= (1 << 30)) {
            throw new IllegalArgumentException("out of range");
        }
        // TODO check realizations for efficiency
        /* (1)
        String ret = "";
        int togo = padlen || 5;
        for (; i || (togo > 0); i >>= 6, togo--) {
            ret = Spec.BASE64.charAt(i & 63) + ret;
        }
        return ret;
        */

        // (2)
        String ret = "";
        while (i != 0) {
            ret = BASE64.charAt(i & 63) + ret;
            i >>= 6;
        }
        if (padlen == null) {
            padlen = 5;
        }
        if (ret.length() < padlen) {
            ret = PADDING_ZEROS.substring(0, padlen - ret.length()) + ret;
        }
        return ret;
    }

    public static int base2int(String token) {
        Matcher m = RE_BASE64.matcher(token);
        if (!m.find()) {
            throw new IllegalArgumentException("Not a base64 token");
        }

        int ret = 0;
        int shift = (token.length() - 1) * 6;
        do {
            int idx = BASE64.indexOf(m.group());
            ret += idx << shift;
            shift -= 6;
        } while (m.find());
        return ret;
    }

    private void ensureParsed() {
        if (parsed) { return; }
        this.quant = SQuant.byCode(str.charAt(0));
        parseBody(str.substring(1));
        this.parsed = true;
    }

    private void parseBody(String body) {
        int bodyStart = (body.charAt(0) == this.quant.code ? 1 : 0);
        int pos = body.indexOf("+");
        this.bare = (pos > -1 ? body.substring(bodyStart, pos) : body.substring(bodyStart));
        this.processId = (pos > -1 ? body.substring(pos + 1) : NO_AUTHOR);
    }

    public SQuant getQuant() {
        return (parsed ? quant : SQuant.byCode(str.charAt(0)));
    }

    public String getBody() {
        return str.substring(1);
    }

    /**
     * @return bare part of spec token
     */
    public String getBare() {
        ensureParsed();
        return bare;
    }

    /**
     * @return processId part of spec token
     */
    public String getProcessId() {
        ensureParsed();
        return processId;
    }

    public SToken overrideQuant(SQuant quant) {
        ensureParsed();
        return new SToken(quant, bare, processId);
    }

    public SToken overrideBare(String bare) {
        ensureParsed();
        return new SToken(quant, bare, processId);
    }

    public SToken overrideExt(String ext) {
        ensureParsed();
        SToken res;
        if (ext != null && ext.length() > 0) {
            res = new SToken(quant, bare, ext);
        } else {
            res = new SToken(quant, bare, NO_AUTHOR);
        }
        return res;
    }

    @Override
    public String toString() {
        return this.str;
    }

    @Override
    public int hashCode() {
        return this.str.hashCode();
    }

    public boolean equals(String token) {
        return this.str.equals(token);
    }

    @Override
    public boolean equals(Object o) {
        return equals(String.valueOf(o));
    }

    @Override
    public int compareTo(SToken other) {
        if (this.str == null) {
            return other == null ? 0 : -1;
        } else {
            return other == null ? 1 : this.str.compareTo(other.str);
        }
    }

    public static final Comparator<SToken> ORDER_BY_QUANT = new Comparator<SToken>() {

        @Override
        public int compare(SToken left, SToken right) {
            if (left == null) {
                return right == null ? 0 : -1;
            } else {
                if (right == null) {
                    return 1;
                }
                return left.getQuant().compareTo(right.getQuant());
            }
        }
    };

    public IdToken toIdToken() {
        ensureParsed();
        if (quant == SQuant.ID) {
            return (IdToken) this;
        } else {
            return new IdToken(bare, processId);
        }
    }

    public VersionToken toVersionToken() {
        ensureParsed();
        if (quant == SQuant.VERSION) {
            return (VersionToken) this;
        } else {
            return new VersionToken(bare, processId);
        }
    }
}
